<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>PowerCC26XX_Config Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">PowerCC26XX_Config Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global configuration structure.  
 <a href="struct_power_c_c26_x_x___config.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_power_c_c26_x_x_8h_source.html">PowerCC26XX.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aa5fa2edd433b84788c63277a21bc8dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#aa5fa2edd433b84788c63277a21bc8dea">policyInitFxn</a></td></tr>
<tr class="memdesc:aa5fa2edd433b84788c63277a21bc8dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Power Policy's initialization function.  <a href="#aa5fa2edd433b84788c63277a21bc8dea">More...</a><br /></td></tr>
<tr class="separator:aa5fa2edd433b84788c63277a21bc8dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4011995544865f832440e9d869b563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_power_8h.html#a333038d1e9cd5f93dda7b83f8a1afa8b">Power_PolicyFxn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#acd4011995544865f832440e9d869b563">policyFxn</a></td></tr>
<tr class="memdesc:acd4011995544865f832440e9d869b563"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Power Policy function.  <a href="#acd4011995544865f832440e9d869b563">More...</a><br /></td></tr>
<tr class="separator:acd4011995544865f832440e9d869b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f68736067cceef7bbc32408b5bec96"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a92f68736067cceef7bbc32408b5bec96">calibrateFxn</a> )(unsigned int)</td></tr>
<tr class="memdesc:a92f68736067cceef7bbc32408b5bec96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to be used for activating RC Oscillator (RCOSC) calibration.  <a href="#a92f68736067cceef7bbc32408b5bec96">More...</a><br /></td></tr>
<tr class="separator:a92f68736067cceef7bbc32408b5bec96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2984f1a5a8939c690067bcaa82f8edba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a2984f1a5a8939c690067bcaa82f8edba">maxStandbyDuration</a></td></tr>
<tr class="memdesc:a2984f1a5a8939c690067bcaa82f8edba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time in system ticks that specifies the maximum duration the device may spend in standby.  <a href="#a2984f1a5a8939c690067bcaa82f8edba">More...</a><br /></td></tr>
<tr class="separator:a2984f1a5a8939c690067bcaa82f8edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7878a56b4a04b55c66e3a32f102fb525"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a7878a56b4a04b55c66e3a32f102fb525">vddrRechargeMargin</a></td></tr>
<tr class="memdesc:a7878a56b4a04b55c66e3a32f102fb525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Margin in SCLK_LF periods subtracted from previous longest VDDR recharge period.  <a href="#a7878a56b4a04b55c66e3a32f102fb525">More...</a><br /></td></tr>
<tr class="separator:a7878a56b4a04b55c66e3a32f102fb525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34214625d9b49848b0297e40d4af8188"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a34214625d9b49848b0297e40d4af8188">enableMaxStandbyDuration</a></td></tr>
<tr class="memdesc:a34214625d9b49848b0297e40d4af8188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean that enables limiting the duration spent in standby.  <a href="#a34214625d9b49848b0297e40d4af8188">More...</a><br /></td></tr>
<tr class="separator:a34214625d9b49848b0297e40d4af8188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabcd65e4700189af683ce0f54e8479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a0dabcd65e4700189af683ce0f54e8479">enablePolicy</a></td></tr>
<tr class="memdesc:a0dabcd65e4700189af683ce0f54e8479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying if the Power Policy function is enabled.  <a href="#a0dabcd65e4700189af683ce0f54e8479">More...</a><br /></td></tr>
<tr class="separator:a0dabcd65e4700189af683ce0f54e8479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5541ad9e9fb883e9bdf9c68d1c0226b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#ae5541ad9e9fb883e9bdf9c68d1c0226b">calibrateRCOSC_LF</a></td></tr>
<tr class="memdesc:ae5541ad9e9fb883e9bdf9c68d1c0226b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying whether the low frequency RC oscillator (RCOSC_LF) should be calibrated.  <a href="#ae5541ad9e9fb883e9bdf9c68d1c0226b">More...</a><br /></td></tr>
<tr class="separator:ae5541ad9e9fb883e9bdf9c68d1c0226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896b6c56c0d1be28de7ce4ef09fe616a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power_c_c26_x_x___config.html#a896b6c56c0d1be28de7ce4ef09fe616a">calibrateRCOSC_HF</a></td></tr>
<tr class="memdesc:a896b6c56c0d1be28de7ce4ef09fe616a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean specifying whether the high frequency RC oscillator (RCOSC_HF) should be calibrated.  <a href="#a896b6c56c0d1be28de7ce4ef09fe616a">More...</a><br /></td></tr>
<tr class="separator:a896b6c56c0d1be28de7ce4ef09fe616a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global configuration structure. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="aa5fa2edd433b84788c63277a21bc8dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fa2edd433b84788c63277a21bc8dea">&sect;&nbsp;</a></span>policyInitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a> PowerCC26XX_Config::policyInitFxn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Power Policy's initialization function. </p>
<p>If the policy does not have an initialization function, 'NULL' should be specified. </p>

</div>
</div>
<a id="acd4011995544865f832440e9d869b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4011995544865f832440e9d869b563">&sect;&nbsp;</a></span>policyFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_power_8h.html#a333038d1e9cd5f93dda7b83f8a1afa8b">Power_PolicyFxn</a> PowerCC26XX_Config::policyFxn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Power Policy function. </p>
<p>When enabled, this function is invoked in the idle loop, to opportunistically select and activate sleep states.</p>
<p>Two reference policies are provided:</p>
<p><a class="el" href="_power_c_c26_x_x_8h.html#ad4ff77b3854dd494aac42e42f70bdee7" title="The Wait for interrupt (WFI) policy. ">PowerCC26XX_doWFI()</a> - a simple policy that invokes CPU wait for interrupt (WFI)</p>
<p><a class="el" href="_power_c_c26_x_x_8h.html#aea49c1a01cb045b1ce6be1ecb3587498" title="The STANDBY Power Policy. ">PowerCC26XX_standbyPolicy()</a> - an agressive policy that considers constraints, time until next scheduled work, and sleep state latencies, and optionally puts the device into the STANDBY state, the IDLE state, or as a minimum, WFI.</p>
<p>Custom policies can be written, and specified via this function pointer.</p>
<p>In addition to this static selection, the Power Policy can be dynamically changed at runtime, via the <a class="el" href="_power_8h.html#aa4af0d238813058bf6146df6021df8cc" title="Set a new Power policy. ">Power_setPolicy()</a> API. </p>

</div>
</div>
<a id="a92f68736067cceef7bbc32408b5bec96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f68736067cceef7bbc32408b5bec96">&sect;&nbsp;</a></span>calibrateFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* PowerCC26XX_Config::calibrateFxn) (unsigned int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to be used for activating RC Oscillator (RCOSC) calibration. </p>
<p>Calibration is normally enabled, via specification of the function <a class="el" href="_power_c_c26_x_x_8h.html#a27a4c7312d5cf59eb699ad5f87104408" title="The RC Oscillator (RCOSC) calibration function. ">PowerCC26XX_calibrate()</a>. This enables high accuracy operation, and faster high frequency crystal oscillator (XOSC_HF) startups.</p>
<p>To disable RCOSC calibration, the function <a class="el" href="_power_c_c26_x_x_8h.html#a39c82b7c57a1b5c013f5e285e98232e9" title="Function to specify when RCOSC calibration is to be disabled. ">PowerCC26XX_noCalibrate()</a> should be specified. </p>

</div>
</div>
<a id="a2984f1a5a8939c690067bcaa82f8edba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2984f1a5a8939c690067bcaa82f8edba">&sect;&nbsp;</a></span>maxStandbyDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PowerCC26XX_Config::maxStandbyDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time in system ticks that specifies the maximum duration the device may spend in standby. </p>
<p>When the power driver tries to put the device into standby and determines the next wakeup should usually be further into the future than maxStandbyDuration system ticks, the power driver will schedule a wakeup maxStandbyDuration into the future. When the device wakes up after being in standby for maxStandbyDuration ticks, the power driver will repeat this process and go back into standby if the state of the system allows it.</p>
<p>Inserting such periodic wakeups can be used to automatically calibrate the RCOSC with a maximum period between calibrations or to force the recalculation of the initial VDDR recharge period. This assumes that the constraint to prohibit standby is not set and that periods of inactivity are long enough for the power driver to put the device into standby.</p>
<p>The value 0 is invalid. When <a class="el" href="struct_power_c_c26_x_x___config.html#a34214625d9b49848b0297e40d4af8188" title="Boolean that enables limiting the duration spent in standby. ">PowerCC26XX_Config.enableMaxStandbyDuration</a> is set to false, any value (including 0) is ignored and the feature is disabled. This feature should not be used to disallow entering standby; the PowerCC26XX_DISALLOW_STANDBY constraint should be used for this purpose. </p>

</div>
</div>
<a id="a7878a56b4a04b55c66e3a32f102fb525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7878a56b4a04b55c66e3a32f102fb525">&sect;&nbsp;</a></span>vddrRechargeMargin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PowerCC26XX_Config::vddrRechargeMargin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Margin in SCLK_LF periods subtracted from previous longest VDDR recharge period. </p>
<p>As the device comes out of standby, it updated its previous initial VDDR recharge period to be closer to the longest recharge period experienced during the time spent in standby before waking up.</p>
<p>vddrRechargeMargin is subtracted from the longest VDDR recharge period in SysCtrlAdjustRechargeAfterPowerDown to ensure there is some margin between the new initial and converged VDDR recharge period. The converged recharge period at a certain temperature is board and device dependent.</p>
<p>The default value of 0 disables this feature. </p>

</div>
</div>
<a id="a34214625d9b49848b0297e40d4af8188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34214625d9b49848b0297e40d4af8188">&sect;&nbsp;</a></span>enableMaxStandbyDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerCC26XX_Config::enableMaxStandbyDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean that enables limiting the duration spent in standby. </p>
<p>If false, the power driver will put the device into standby as appropriate without duration restrictions.</p>
<p>If true, the the power driver will force a wakeup every <a class="el" href="struct_power_c_c26_x_x___config.html#a2984f1a5a8939c690067bcaa82f8edba" title="Time in system ticks that specifies the maximum duration the device may spend in standby. ">PowerCC26XX_Config.maxStandbyDuration</a> system ticks before reevaluating the state of the system.</p>
<p>This is set to false by default. </p>

</div>
</div>
<a id="a0dabcd65e4700189af683ce0f54e8479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabcd65e4700189af683ce0f54e8479">&sect;&nbsp;</a></span>enablePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerCC26XX_Config::enablePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying if the Power Policy function is enabled. </p>
<p>If 'true', the policy function will be invoked once for each pass of the idle loop.</p>
<p>If 'false', the policy will not be invoked.</p>
<p>In addition to this static setting, the power policy can be dynamically enabled and disabled at runtime, via the <a class="el" href="_power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f" title="Enable the configured power policy to run when the CPU is idle. ">Power_enablePolicy()</a> and <a class="el" href="_power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a" title="Disable the configured power policy from running when the CPU is idle. ">Power_disablePolicy()</a> functions, respectively. </p>

</div>
</div>
<a id="ae5541ad9e9fb883e9bdf9c68d1c0226b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5541ad9e9fb883e9bdf9c68d1c0226b">&sect;&nbsp;</a></span>calibrateRCOSC_LF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerCC26XX_Config::calibrateRCOSC_LF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying whether the low frequency RC oscillator (RCOSC_LF) should be calibrated. </p>
<p>If RCOSC calibration is enabled (above, via specification of an appropriate calibrateFxn), this Boolean specifies whether RCOSC_LF should be calibrated. </p>

</div>
</div>
<a id="a896b6c56c0d1be28de7ce4ef09fe616a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896b6c56c0d1be28de7ce4ef09fe616a">&sect;&nbsp;</a></span>calibrateRCOSC_HF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PowerCC26XX_Config::calibrateRCOSC_HF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean specifying whether the high frequency RC oscillator (RCOSC_HF) should be calibrated. </p>
<p>If RCOSC calibration is enabled (above, via specification of an appropriate calibrateFxn), this Boolean specifies whether RCOSC_HF should be calibrated. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_power_c_c26_x_x_8h_source.html">PowerCC26XX.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
