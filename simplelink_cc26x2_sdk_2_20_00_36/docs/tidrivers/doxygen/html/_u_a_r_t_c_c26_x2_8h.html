<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>UARTCC26X2.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_909bee6dba95683a10cf8e43b6520a31.html">tidrivers_cc13xx_cc26xx_3_60_01_00</a></li><li class="navelem"><a class="el" href="dir_c5f8bfd2b00c3d9482b35ab5c4e473f6.html">source</a></li><li class="navelem"><a class="el" href="dir_06d62f3489950a654127c0b824c52048.html">ti</a></li><li class="navelem"><a class="el" href="dir_f72c65173629b6c97d424cefc852539a.html">drivers</a></li><li class="navelem"><a class="el" href="dir_70f6c4acee61d425612326b6f57d5ce1.html">uart</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">UARTCC26X2.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>UART driver implementation for a CC26X2 UART controller. </p>
<p>============================================================================</p>
<h1>Driver include</h1>
<p>The UART header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_8h.html">ti/drivers/UART.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_c_c26_x2_8h.html">ti/drivers/uart/UARTCC26X2.h</a>&gt;</span></div></div><!-- fragment --><p>Refer to <a class="el" href="_u_a_r_t_8h.html">UART.h</a> for a complete description of APIs.</p>
<h1>Overview</h1>
<p>The general UART API should used in application code, i.e. <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> is used instead of UARTCC26X2_open(). The board file will define the device specific config, and casting in the general API will ensure that the correct device specific functions are called. This is also reflected in the example code in <a class="el" href="_u_a_r_t_c_c26_x_x_8h.html#USE_CASES">Use Cases</a>.</p>
<h1>General Behavior</h1>
<p>Before using the UART in CC26X2:</p><ul>
<li>The UART driver is initialized by calling <a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a>.</li>
<li>The UART HW is configured and flags system dependencies (e.g. IOs, power, etc.) by calling <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</li>
<li>The RX and TX can operate independently of each other.</li>
</ul>
<p>The following is true for receive operation:</p><ul>
<li>RX is enabled by calling <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>.</li>
<li>All received bytes are ignored after <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> is called, until the first <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>.</li>
<li>If an RX error occur, RX is turned off and all bytes received before the error occured are returned.</li>
<li>After a successful read, RX remains on. <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> must be called again before FIFO goes full in order to avoid overflow. It is safe to call another <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> from the read callback, See <a class="el" href="_u_a_r_t_c_c26_x_x_8h.html#USE_CASE_CB">Receive Continously</a> use case below.</li>
<li>If a read times out (in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a> mode), RX will remain on. <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> must be called again before FIFO goes full in order to avoid overflow.</li>
<li>The <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> supports partial return, that can be used if the receive size is unknown. See <a class="el" href="_u_a_r_t_c_c26_x_x_8h.html#USE_CASES">Use Cases</a> below.</li>
<li>The RingBuf serves as an extension of the FIFO. If data is received when <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> is not called, data will be stored in the RingBuf. The functionality of the RingBuf has been tested with a size of 32. This size can be changed to suit the application.</li>
</ul>
<p>The following apply for transmit operation:</p><ul>
<li>TX is enabled by calling <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>.</li>
<li>If the <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> succeeds, the TX is disabled.</li>
</ul>
<p>If UART is no longer needed by application:</p><ul>
<li>Release system dependencies for UART by calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>.</li>
</ul>
<p>If the UART is configured in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> mode:</p><ul>
<li>The error handling callback is run in a HWI context.</li>
<li>The application's callback is run in a SWI context.</li>
</ul>
<h1>Error handling</h1>
<h2>Read errors</h2>
<p>If an error occurs during read operation:</p><ul>
<li>All bytes received up until an error occurs will be returned, with the error signaled in the <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html#a2effdee4c5dd455415822941c708d1cf">UARTCC26X2_Object.status</a> field. The RX is then turned off and all bytes will be ignored until a new read is issued. Note that only the read is cancelled when the error occurs. If a write was active while the RX error occurred, it will complete. A new <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> will reset the <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html#a2effdee4c5dd455415822941c708d1cf">UARTCC26X2_Object.status</a> field to 0.</li>
<li>If a RX break error occurs, an extra 0 byte will also be returned by the <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>.</li>
</ul>
<h2>General timeout</h2>
<p>A timeout value can only be specified for reads and writes in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>. If a timeout occurs during a read when in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, the number of bytes received will be returned. After a read timeout, RX will be turned off and the device allowed to enter standby. For more details see <a class="el" href="_u_a_r_t_c_c26_x_x_8h.html#POWER_MANAGEMENT">Power Management</a> chapter below.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> there is no timeout and the application must call <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> or <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> to abort the operation.</p>
<h2>Closing driver during an ongoing read/write</h2>
<p>It's safe to call <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> during an ongoing <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> and/or <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>, this will cancel the ongoing RX/TX immediately.</p>
<p>The RX callback is alwyas called when you call <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> if there's an ongoing read. Note that if <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> is called during an ongoing read, the size provided in the RX callback function is 0 if &lt; 16 bytes were received before calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>. This is because 16 bytes is the RX watermark that triggers the ISR to copy bytes from the internal UART FIFO to the software RX buffer.</p>
<p>The TX callback is always called when you call <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> if there's an ongoing write. The driver does not wait until a byte is transmitted correctly, so if <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> is called in the middle of sending a byte, this byte will be corrupted.</p>
<h1>Power Management<a class="anchor" id="UARTCC26X2_POWER_MANAGEMENT"></a></h1>
<p>The TI-RTOS power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</p>
<p>The UARTCC26X2 driver sets a power constraint during operation to keep the device out of standby. When the operation has finished, the power constraint is released. The following statements are valid:</p><ul>
<li>After <a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>: the device is not allowed to enter standby.</li>
<li>During <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>: the device cannot enter standby.</li>
<li>After an RX error (overrun, break, parity, framing): RX is disabled and the device is allowed to enter standby.</li>
<li>After a successful <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a>: The device is not allowed to enter standby and RX remains on.<ul>
<li><em>Note</em>: Application thread should typically either issue another read after <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> completes successfully, or call either <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> or UART_control(uart, UART_CMD_RXDISABLE, 0), to disable RX and allow the device to enter standby.</li>
</ul>
</li>
<li>After <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> times out in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>: The device is allowed to enter standby and RX is turned off. To prevent RX from being disabled and disallowing standby on a read timeout or read error, the application can call UART_control(uart, UART_CMD_RXENABLE, 0).</li>
<li>During <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a>: the device cannot enter standby.</li>
<li>After <a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> succeeds: the device can enter standby.</li>
<li>If <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> is called: the device can enter standby.</li>
<li>After write timeout: the device can enter standby.</li>
</ul>
<h1>Flow Control</h1>
<p>To enable Flow Control, the RTS and CTS pins must be assigned in the <a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html" title="UARTCC26X2 Hardware attributes. ">UARTCC26X2_HWAttrs</a> and flowControl must be set to UARTCC26X2_FLOWCTRL_HARDWARE: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a> uartCC26X2HWAttrs[] = {</div><div class="line">    {</div><div class="line">        .<a class="code" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html#a3c266863e2a35633ba1aa2cfad060139">baseAddr</a>    = UART0_BASE,</div><div class="line">        .powerMngrId = PERIPH_UART0,</div><div class="line">        .intNum      = INT_UART0,</div><div class="line">        .intPriority = ~0,</div><div class="line">        .swiPriority = 0,</div><div class="line">        .flowControl = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a309f737b08cfa20f0e31db765920ce9d">UARTCC26X2_FLOWCTRL_HARDWARE</a>,</div><div class="line">        .txPin       = Board_UART_TX,</div><div class="line">        .rxPin       = Board_UART_RX,</div><div class="line">        .ctsPin      = Board_UART_CTS,</div><div class="line">        .rtsPin      = Board_UART_RTS</div><div class="line">        .ringBufPtr  = uartCC26X2RingBuffer[0],</div><div class="line">        .ringBufSize = <span class="keyword">sizeof</span>(uartCC26X2RingBuffer[0]),</div><div class="line">        .txIntFifoThr= <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aabf454142de036a9b84a8aa4b34806a5f">UARTCC26X2_FIFO_THRESHOLD_1_8</a>,</div><div class="line">        .rxIntFifoThr= <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aac458f7c6fa133f9124f56db778b2adc1">UARTCC26X2_FIFO_THRESHOLD_4_8</a></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>If the RTS and CTS pins are set to <a class="el" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf" title="Pin ID used to indicate no pin. ">PIN_UNASSIGNED</a>, or flowControl is set to UARTCC26X2_FLOWCONTROL_NONE, the flow control is disabled. An example is shown in the <a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html" title="UARTCC26X2 Hardware attributes. ">UARTCC26X2_HWAttrs</a> description.</p>
<h1>Supported Functions</h1>
<table class="doxtable">
<tr>
<th>Generic API function </th><th>API function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> </td><td>UARTCC26X2_init() </td><td>Initialize UART driver </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </td><td>UARTCC26X2_open() </td><td>Initialize UART HW and set system dependencies </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> </td><td>UARTCC26X2_close() </td><td>Disable UART HW and release system dependencies </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> </td><td>UARTCC26X2_control() </td><td>Configure an already opened UART handle </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> </td><td>UARTCC26X2_read() </td><td>Start read from UART </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> </td><td>UARTCC26X2_readCancel() </td><td>Cancel ongoing read from UART </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a3ac6ed8cfd03b84198ba6adcd8c248e6" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a> </td><td>UARTCC26X2_readPolling() </td><td>Polling read from UART </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f" title="Function that writes data to a UART with interrupts enabled. ">UART_write()</a> </td><td>UARTCC26X2_write() </td><td>Start write to UART </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> </td><td>UARTCC26X2_writeCancel() </td><td>Cancel ongoing write to UART </td></tr>
<tr>
<td><a class="el" href="_u_a_r_t_8h.html#ad8cda326eb3c05ee05950680bee42e5a" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a> </td><td>UARTCC26X2_writePolling()</td><td>Polling write to UART </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>All calls should go through the generic API</dd></dl>
<h1>Use Cases<a class="anchor" id="UARTCC26X2_USE_CASES"></a></h1>
<h2>Basic Receive</h2>
<p>Receive 100 bytes over UART in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>. </p><div class="fragment"><div class="line"><a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle;</div><div class="line"><a class="code" href="struct_u_a_r_t___params__.html">UART_Params</a> params;</div><div class="line">uint8_t rxBuf[100];         <span class="comment">// Receive buffer</span></div><div class="line">uint32_t timeoutUs = 5000;  <span class="comment">// 5ms timeout, default timeout is no timeout (BIOS_WAIT_FOREVER)</span></div><div class="line"></div><div class="line"><span class="comment">// Init UART and specify non-default parameters</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#a4423b9250bb409710872f0a00b3383c7">baudRate</a>      = 9600;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#afa84cf6a6b53150ab6908785a7aac41d">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#ad7d6962c8a9f89ec9ea12f2b8485f43d">readTimeout</a>   = timeoutUs / ClockP_tickPeriod; <span class="comment">// Default tick period is 10us</span></div><div class="line"></div><div class="line"><span class="comment">// Open the UART and do the read</span></div><div class="line">handle = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(Board_UART, &amp;params);</div><div class="line"><span class="keywordtype">int</span> rxBytes = <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(handle, rxBuf, 100);</div></div><!-- fragment --><h2>Receive with Return Partial</h2>
<p>This use case will read in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a> until the wanted amount of bytes is received or until a started reception is inactive for a 32-bit period. This <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> call can also be used when unknown amount of bytes shall be read. Note: The partial return is also possible in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> mode. </p><div class="fragment"><div class="line"><a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle;</div><div class="line"><a class="code" href="struct_u_a_r_t___params__.html">UART_Params</a> params;</div><div class="line">uint8_t rxBuf[100];      <span class="comment">// Receive buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Init UART and specify non-default parameters</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#a4423b9250bb409710872f0a00b3383c7">baudRate</a>      = 9600;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#afa84cf6a6b53150ab6908785a7aac41d">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line"></div><div class="line"><span class="comment">// Open the UART and initiate the partial read</span></div><div class="line">handle = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(Board_UART, &amp;params);</div><div class="line"><span class="comment">// Enable RETURN_PARTIAL</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a5ce79dc51ddc3ef73e8f08983bfee2c7">UART_control</a>(handle, <a class="code" href="group___u_a_r_t___c_m_d.html#ga9a21e7999f55e4efb146f202337c9381">UARTCC26X2_CMD_RETURN_PARTIAL_ENABLE</a>, NULL);</div><div class="line"><span class="comment">// Begin read</span></div><div class="line"><span class="keywordtype">int</span> rxBytes = <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(handle, rxBuf, 100));</div></div><!-- fragment --><h2>Basic Transmit</h2>
<p>This case will configure the UART to send the data in txBuf in BLOCKING_MODE. </p><div class="fragment"><div class="line"><a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle;</div><div class="line"><a class="code" href="struct_u_a_r_t___params__.html">UART_Params</a> params;</div><div class="line">uint8_t txBuf[] = <span class="stringliteral">&quot;Hello World&quot;</span>;    <span class="comment">// Transmit buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Init UART and specify non-default parameters</span></div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#a4423b9250bb409710872f0a00b3383c7">baudRate</a>      = 9600;</div><div class="line">params.<a class="code" href="struct_u_a_r_t___params__.html#afa84cf6a6b53150ab6908785a7aac41d">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line"></div><div class="line"><span class="comment">// Open the UART and do the write</span></div><div class="line">handle = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(Board_UART, &amp;params);</div><div class="line"><a class="code" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a>(handle, txBuf, <span class="keyword">sizeof</span>(txBuf));</div></div><!-- fragment --><h2>Receive Continously in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a><a class="anchor" id="UARTCC26X2_USE_CASE_CB"></a></h2>
<p>This case will configure the UART to receive and transmit continously in <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>, and transmit them back via UART TX. Note that <a class="el" href="struct_u_a_r_t___params__.html#ad7d6962c8a9f89ec9ea12f2b8485f43d">UART_Params.readTimeout</a> is not in use when using <a class="el" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> mode. </p><div class="fragment"><div class="line"><span class="preprocessor">#define MAX_NUM_RX_BYTES    1000   // Maximum RX bytes to receive in one go</span></div><div class="line"><span class="preprocessor">#define MAX_NUM_TX_BYTES    1000   // Maximum TX bytes to send in one go</span></div><div class="line"></div><div class="line">uint32_t wantedRxBytes;            <span class="comment">// Number of bytes received so far</span></div><div class="line">uint8_t rxBuf[MAX_NUM_RX_BYTES];   <span class="comment">// Receive buffer</span></div><div class="line">uint8_t txBuf[MAX_NUM_TX_BYTES];   <span class="comment">// Transmit buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Read callback function</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> readCallback(<a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle, <span class="keywordtype">void</span> *rxBuf, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    <span class="comment">// Make sure we received all expected bytes</span></div><div class="line">    <span class="keywordflow">if</span> (size == wantedRxBytes) {</div><div class="line">        <span class="comment">// Copy bytes from RX buffer to TX buffer</span></div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; i++)</div><div class="line">           txBuf[i] = ((uint8_t*)rxBuf)[i];</div><div class="line"></div><div class="line">       <span class="comment">// Echo the bytes received back to transmitter</span></div><div class="line">       <a class="code" href="_u_a_r_t_8h.html#a1036c2d5258ff70e9afe6cbfc326544f">UART_write</a>(handle, txBuf, size);</div><div class="line"></div><div class="line">       <span class="comment">// Start another read, with size the same as it was during first call to</span></div><div class="line">       <span class="comment">// UART_read()</span></div><div class="line">       <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(handle, rxBuf, wantedRxBytes);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Handle error or call to UART_readCancel()</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Write callback function</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> writeCallback(<a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle, <span class="keywordtype">void</span> *rxBuf, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    <span class="comment">// Do nothing</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> taskFxn(uintptr_t a0, uintptr_t a1)</div><div class="line">{</div><div class="line">    <a class="code" href="struct_u_a_r_t___config__.html">UART_Handle</a> handle;</div><div class="line">    <a class="code" href="struct_u_a_r_t___params__.html">UART_Params</a> params;</div><div class="line"></div><div class="line">    <span class="comment">// Init UART</span></div><div class="line">    <a class="code" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">UART_init</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Specify non-default parameters</span></div><div class="line">    <a class="code" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#a4423b9250bb409710872f0a00b3383c7">baudRate</a>      = 9600;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#aba1e2f7319961148683112ce7c46fef9">writeMode</a>     = <a class="code" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#afa84cf6a6b53150ab6908785a7aac41d">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#ad8882b7e15bb07a3cb150dec73f05b4d">writeCallback</a> = writeCallback;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#a3595f9cd8c7629a977f6833c2578f7f9">readMode</a>      = <a class="code" href="_u_a_r_t_8h.html#a5b0b54681a2ee6ed54e5b24f49324173ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#ac0748b65265ff4fced9fee6a8c003398">readDataMode</a>  = <a class="code" href="_u_a_r_t_8h.html#a1dc5f5e884c16722be3b218456f32df9aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div><div class="line">    params.<a class="code" href="struct_u_a_r_t___params__.html#a90143ce78450225d957e0d05289564d3">readCallback</a>  = readCallback;</div><div class="line"></div><div class="line">    <span class="comment">// Open the UART and initiate the first read</span></div><div class="line">    handle = <a class="code" href="_u_a_r_t_8h.html#ab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a>(Board_UART, &amp;params);</div><div class="line">    wantedRxBytes = 16;</div><div class="line">    <span class="keywordtype">int</span> rxBytes = <a class="code" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135">UART_read</a>(handle, rxBuf, wantedRxBytes);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>); <span class="comment">// Wait forever</span></div><div class="line">}</div></div><!-- fragment --><h1>Baud Rate</h1>
<p>The CC26xx driver supports baud rates up to 3Mbaud. However, when receiving more than 32 bytes back-to-back the baud rate is limited to approximately 2Mbaud. The throughput is also dependent on the user application.</p>
<h1>Stack requirements</h1>
<p>There are no additional stack requirements for calling <a class="el" href="_u_a_r_t_8h.html#a15d77f489566ff9f7c9c28d25e9a0135" title="Function that reads data from a UART with interrupt enabled. ">UART_read()</a> within its own callback. </p><hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;ti/drivers/dpl/ClockP.h&gt;</code><br />
<code>#include &lt;ti/drivers/dpl/HwiP.h&gt;</code><br />
<code>#include &lt;ti/drivers/dpl/SemaphoreP.h&gt;</code><br />
<code>#include &lt;ti/drivers/dpl/SwiP.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_power_8h_source.html">ti/drivers/Power.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_u_a_r_t_8h_source.html">ti/drivers/UART.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_p_i_n_c_c26_x_x_8h_source.html">ti/drivers/pin/PINCC26XX.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_ring_buf_8h_source.html">ti/drivers/utils/RingBuf.h</a>&gt;</code><br />
</div>
<p><a href="_u_a_r_t_c_c26_x2_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTCC26X2 Hardware attributes.  <a href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTCC26X2 Object.  <a href="struct_u_a_r_t_c_c26_x2___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa44868ef5d29eb67e1b148cb5c01e53c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#aa44868ef5d29eb67e1b148cb5c01e53c">UARTCC26X2_FLOWCTRL_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa44868ef5d29eb67e1b148cb5c01e53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No hardware flow control.  <a href="#aa44868ef5d29eb67e1b148cb5c01e53c">More...</a><br /></td></tr>
<tr class="separator:aa44868ef5d29eb67e1b148cb5c01e53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f737b08cfa20f0e31db765920ce9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a309f737b08cfa20f0e31db765920ce9d">UARTCC26X2_FLOWCTRL_HARDWARE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a309f737b08cfa20f0e31db765920ce9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware flow control.  <a href="#a309f737b08cfa20f0e31db765920ce9d">More...</a><br /></td></tr>
<tr class="separator:a309f737b08cfa20f0e31db765920ce9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a21e7999f55e4efb146f202337c9381"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga9a21e7999f55e4efb146f202337c9381">UARTCC26X2_CMD_RETURN_PARTIAL_ENABLE</a>&#160;&#160;&#160;(<a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga0f5a809e0884da33fef102236eb51644">UART_CMD_RESERVED</a> + 0)</td></tr>
<tr class="memdesc:ga9a21e7999f55e4efb146f202337c9381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command used by UART_control to enable partial return.  <a href="group___u_a_r_t___c_m_d.html#ga9a21e7999f55e4efb146f202337c9381">More...</a><br /></td></tr>
<tr class="separator:ga9a21e7999f55e4efb146f202337c9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14c4e92cd925d03a5308ef2885a6fbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gaa14c4e92cd925d03a5308ef2885a6fbe">UARTCC26X2_CMD_RETURN_PARTIAL_DISABLE</a>&#160;&#160;&#160;(<a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga0f5a809e0884da33fef102236eb51644">UART_CMD_RESERVED</a> + 1)</td></tr>
<tr class="memdesc:gaa14c4e92cd925d03a5308ef2885a6fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command used by UART_control to disable partial return.  <a href="group___u_a_r_t___c_m_d.html#gaa14c4e92cd925d03a5308ef2885a6fbe">More...</a><br /></td></tr>
<tr class="separator:gaa14c4e92cd925d03a5308ef2885a6fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8657ba4d475506b57be9c27720d82e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gaa8657ba4d475506b57be9c27720d82e8">UARTCC26X2_CMD_RX_FIFO_FLUSH</a>&#160;&#160;&#160;(<a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga0f5a809e0884da33fef102236eb51644">UART_CMD_RESERVED</a> + 2)</td></tr>
<tr class="memdesc:gaa8657ba4d475506b57be9c27720d82e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command used by UART_control to flush the RX FIFO.  <a href="group___u_a_r_t___c_m_d.html#gaa8657ba4d475506b57be9c27720d82e8">More...</a><br /></td></tr>
<tr class="separator:gaa8657ba4d475506b57be9c27720d82e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb9353dfebb693e3bcd1d33153f2826"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#aeeb9353dfebb693e3bcd1d33153f2826">UARTCC26X2_FIFO_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:aeeb9353dfebb693e3bcd1d33153f2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a14763435cb0213af4137647770491188"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">UARTCC26X2_FifoThreshold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a14763435cb0213af4137647770491188">UARTCC26X2_FifoThreshold</a></td></tr>
<tr class="memdesc:a14763435cb0213af4137647770491188"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART TX/RX interrupt FIFO threshold select.  <a href="#a14763435cb0213af4137647770491188">More...</a><br /></td></tr>
<tr class="separator:a14763435cb0213af4137647770491188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2115103e1d5f42427f7e7064bc33bb47"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a2115103e1d5f42427f7e7064bc33bb47">UARTCC26X2_ErrorCallback</a>) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint32_t error)</td></tr>
<tr class="memdesc:a2115103e1d5f42427f7e7064bc33bb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of an optional callback function used by the UART driver to notify the application when a receive error (FIFO overrun, parity error, etc) occurs.  <a href="#a2115103e1d5f42427f7e7064bc33bb47">More...</a><br /></td></tr>
<tr class="separator:a2115103e1d5f42427f7e7064bc33bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb886d5e661b394fae31eef73718f5f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a9eb886d5e661b394fae31eef73718f5f">UARTCC26X2_HWAttrs</a></td></tr>
<tr class="memdesc:a9eb886d5e661b394fae31eef73718f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTCC26X2 Hardware attributes.  <a href="#a9eb886d5e661b394fae31eef73718f5f">More...</a><br /></td></tr>
<tr class="separator:a9eb886d5e661b394fae31eef73718f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97966e8407c7a450cd719f6bc1f85f1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#af97966e8407c7a450cd719f6bc1f85f1">UARTCC26X2_Object</a></td></tr>
<tr class="memdesc:af97966e8407c7a450cd719f6bc1f85f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTCC26X2 Object.  <a href="#af97966e8407c7a450cd719f6bc1f85f1">More...</a><br /></td></tr>
<tr class="separator:af97966e8407c7a450cd719f6bc1f85f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a9fb70d27e055e05104154aa005ee5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a87a9fb70d27e055e05104154aa005ee5">UARTCC26X2_Handle</a></td></tr>
<tr class="separator:a87a9fb70d27e055e05104154aa005ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a324b806f51c06b9e50d2acfdd21c5d2a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">UARTCC26X2_FifoThreshold</a> { <br />
&#160;&#160;<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aa15d5c2974812d642f8075cd969aebc18">UARTCC26X2_FIFO_THRESHOLD_DEFAULT</a> = 0, 
<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aabf454142de036a9b84a8aa4b34806a5f">UARTCC26X2_FIFO_THRESHOLD_1_8</a>, 
<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aaf1da512c742f02d5d3068b0b030939f3">UARTCC26X2_FIFO_THRESHOLD_2_8</a>, 
<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aac458f7c6fa133f9124f56db778b2adc1">UARTCC26X2_FIFO_THRESHOLD_4_8</a>, 
<br />
&#160;&#160;<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aad2f7a83fe94872a2d403f10f7dc580a5">UARTCC26X2_FIFO_THRESHOLD_6_8</a>, 
<a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aa758f49ceb6c6175678a2c2b8bd7f9a43">UARTCC26X2_FIFO_THRESHOLD_7_8</a>
<br />
 }<tr class="memdesc:a324b806f51c06b9e50d2acfdd21c5d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART TX/RX interrupt FIFO threshold select.  <a href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a324b806f51c06b9e50d2acfdd21c5d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac5ed668954e94caaea6e20fe0cd03caa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_u_a_r_t_8h.html#ad50e0d914874c8fcbc16b451984a8f5e">UART_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_c_c26_x2_8h.html#ac5ed668954e94caaea6e20fe0cd03caa">UARTCC26X2_fxnTable</a></td></tr>
<tr class="separator:ac5ed668954e94caaea6e20fe0cd03caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa44868ef5d29eb67e1b148cb5c01e53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44868ef5d29eb67e1b148cb5c01e53c">&sect;&nbsp;</a></span>UARTCC26X2_FLOWCTRL_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UARTCC26X2_FLOWCTRL_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No hardware flow control. </p>

</div>
</div>
<a id="a309f737b08cfa20f0e31db765920ce9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309f737b08cfa20f0e31db765920ce9d">&sect;&nbsp;</a></span>UARTCC26X2_FLOWCTRL_HARDWARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UARTCC26X2_FLOWCTRL_HARDWARE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware flow control. </p>

</div>
</div>
<a id="aeeb9353dfebb693e3bcd1d33153f2826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb9353dfebb693e3bcd1d33153f2826">&sect;&nbsp;</a></span>UARTCC26X2_FIFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UARTCC26X2_FIFO_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the TX and RX FIFOs is 32 items </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a14763435cb0213af4137647770491188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14763435cb0213af4137647770491188">&sect;&nbsp;</a></span>UARTCC26X2_FifoThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">UARTCC26X2_FifoThreshold</a>  <a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">UARTCC26X2_FifoThreshold</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART TX/RX interrupt FIFO threshold select. </p>
<p>Defined FIFO thresholds for generation of both TX interrupt and RX interrupt. The default value (UARTCC26X2_FIFO_THRESHOLD_DEFAULT) is defined for backwards compatibility handling. If the RX and TX FIFO &amp; thresholds are not set in the HwAttrs, or are set to UARTCC26X2_FIFO_THRESHOLD_DEFAULT, the RX interrupt FIFO threshold is set to 4/8 full, and the TX interrupt FIFO threshold is set to 1/8 full. </p>

</div>
</div>
<a id="a2115103e1d5f42427f7e7064bc33bb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2115103e1d5f42427f7e7064bc33bb47">&sect;&nbsp;</a></span>UARTCC26X2_ErrorCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UARTCC26X2_ErrorCallback) (<a class="el" href="_u_a_r_t_8h.html#ab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint32_t error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of an optional callback function used by the UART driver to notify the application when a receive error (FIFO overrun, parity error, etc) occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">error</td><td>The current value of the receive status register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb886d5e661b394fae31eef73718f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb886d5e661b394fae31eef73718f5f">&sect;&nbsp;</a></span>UARTCC26X2_HWAttrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a>  <a class="el" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UARTCC26X2 Hardware attributes. </p>
<p>The fields, baseAddr and intNum are used by driverlib APIs and therefore must be populated by driverlib macro definitions. These definitions are found under the device family in:</p><ul>
<li>inc/hw_memmap.h</li>
<li>inc/hw_ints.h</li>
<li>driverlib/uart.h</li>
</ul>
<p>intPriority is the UART peripheral's interrupt priority, as defined by the underlying OS. It is passed unmodified to the underlying OS's interrupt handler creation code, so you need to refer to the OS documentation for usage. For example, for SYS/BIOS applications, refer to the ti.sysbios.family.arm.m3.Hwi documentation for SYS/BIOS usage of interrupt priorities. If the driver uses the ti.dpl interface instead of making OS calls directly, then the HwiP port handles the interrupt priority in an OS specific way. In the case of the SYS/BIOS port, intPriority is passed unmodified to Hwi_create(). The CC26xx uses three of the priority bits, meaning ~0 has the same effect as (7 &lt;&lt; 5). </p><pre class="fragment">  (7 &lt;&lt; 5) will apply the lowest priority.
  (1 &lt;&lt; 5) will apply the highest priority.
</pre><p>Setting the priority to 0 is not supported by this driver. HWI's with priority 0 ignore the HWI dispatcher to support zero-latency interrupts, thus invalidating the critical sections in this driver.</p>
<p>A sample structure is shown below: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uartCC26X2RingBuffer[2][32];</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html">UARTCC26X2_HWAttrs</a> uartCC26X2HWAttrs[] = {</div><div class="line">    {</div><div class="line">        .<a class="code" href="struct_u_a_r_t_c_c26_x2___h_w_attrs.html#a3c266863e2a35633ba1aa2cfad060139">baseAddr</a>     = UARTA0_BASE,</div><div class="line">        .intNum       = INT_UART0_COMB,</div><div class="line">        .intPriority  = (~0),</div><div class="line">        .swiPriority  = 0,</div><div class="line">        .ringBufPtr   = uartCC26X2RingBuffer[0],</div><div class="line">        .ringBufSize  = <span class="keyword">sizeof</span>(uartCC26X2RingBuffer[0]),</div><div class="line">        .flowControl  = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#aa44868ef5d29eb67e1b148cb5c01e53c">UARTCC26X2_FLOWCTRL_NONE</a>,</div><div class="line">        .rxPin        = IOID_2,</div><div class="line">        .txPin        = IOID_3,</div><div class="line">        .ctsPin       = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .rtsPin       = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .txIntFifoThr = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aabf454142de036a9b84a8aa4b34806a5f">UARTCC26X2_FIFO_THRESHOLD_1_8</a>,</div><div class="line">        .rxIntFifoThr = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aac458f7c6fa133f9124f56db778b2adc1">UARTCC26X2_FIFO_THRESHOLD_4_8</a>,</div><div class="line">        .errorFxn     = NULL</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .baseAddr     = UART1_BASE,</div><div class="line">        .intNum       = INT_UART1_COMB,</div><div class="line">        .intPriority  = (~0),</div><div class="line">        .swiPriority  = 0,</div><div class="line">        .ringBufPtr   = uartCC26X2RingBuffer[1],</div><div class="line">        .ringBufSize  = <span class="keyword">sizeof</span>(uartCC26X2RingBuffer[1]),</div><div class="line">        .flowControl  = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#aa44868ef5d29eb67e1b148cb5c01e53c">UARTCC26X2_FLOWCTRL_NONE</a>,</div><div class="line">        .rxPin        = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .txPin        = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .ctsPin       = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .rtsPin       = <a class="code" href="_p_i_n_8h.html#aba219226dfdc9ea2fb82d6a7995395bf">PIN_UNASSIGNED</a>,</div><div class="line">        .txIntFifoThr = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aabf454142de036a9b84a8aa4b34806a5f">UARTCC26X2_FIFO_THRESHOLD_1_8</a>,</div><div class="line">        .rxIntFifoThr = <a class="code" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2aac458f7c6fa133f9124f56db778b2adc1">UARTCC26X2_FIFO_THRESHOLD_4_8</a>,</div><div class="line">        .errorFxn     = NULL</div><div class="line">    },</div><div class="line">};</div></div><!-- fragment --><p>The .ctsPin and .rtsPin must be assigned to enable flow control. </p>

</div>
</div>
<a id="af97966e8407c7a450cd719f6bc1f85f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97966e8407c7a450cd719f6bc1f85f1">&sect;&nbsp;</a></span>UARTCC26X2_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a>  <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UARTCC26X2 Object. </p>
<p>The application must not access any member variables of this structure! </p>

</div>
</div>
<a id="a87a9fb70d27e055e05104154aa005ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a9fb70d27e055e05104154aa005ee5">&sect;&nbsp;</a></span>UARTCC26X2_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t_c_c26_x2___object.html">UARTCC26X2_Object</a> * <a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a87a9fb70d27e055e05104154aa005ee5">UARTCC26X2_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a324b806f51c06b9e50d2acfdd21c5d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b806f51c06b9e50d2acfdd21c5d2a">&sect;&nbsp;</a></span>UARTCC26X2_FifoThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_c_c26_x2_8h.html#a324b806f51c06b9e50d2acfdd21c5d2a">UARTCC26X2_FifoThreshold</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART TX/RX interrupt FIFO threshold select. </p>
<p>Defined FIFO thresholds for generation of both TX interrupt and RX interrupt. The default value (UARTCC26X2_FIFO_THRESHOLD_DEFAULT) is defined for backwards compatibility handling. If the RX and TX FIFO &amp; thresholds are not set in the HwAttrs, or are set to UARTCC26X2_FIFO_THRESHOLD_DEFAULT, the RX interrupt FIFO threshold is set to 4/8 full, and the TX interrupt FIFO threshold is set to 1/8 full. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aa15d5c2974812d642f8075cd969aebc18"></a>UARTCC26X2_FIFO_THRESHOLD_DEFAULT&#160;</td><td class="fielddoc"><p>Use default FIFO threshold </p>
</td></tr>
<tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aabf454142de036a9b84a8aa4b34806a5f"></a>UARTCC26X2_FIFO_THRESHOLD_1_8&#160;</td><td class="fielddoc"><p>FIFO threshold of 1/8 full </p>
</td></tr>
<tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aaf1da512c742f02d5d3068b0b030939f3"></a>UARTCC26X2_FIFO_THRESHOLD_2_8&#160;</td><td class="fielddoc"><p>FIFO threshold of 2/8 full </p>
</td></tr>
<tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aac458f7c6fa133f9124f56db778b2adc1"></a>UARTCC26X2_FIFO_THRESHOLD_4_8&#160;</td><td class="fielddoc"><p>FIFO threshold of 4/8 full </p>
</td></tr>
<tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aad2f7a83fe94872a2d403f10f7dc580a5"></a>UARTCC26X2_FIFO_THRESHOLD_6_8&#160;</td><td class="fielddoc"><p>FIFO threshold of 6/8 full </p>
</td></tr>
<tr><td class="fieldname"><a id="a324b806f51c06b9e50d2acfdd21c5d2aa758f49ceb6c6175678a2c2b8bd7f9a43"></a>UARTCC26X2_FIFO_THRESHOLD_7_8&#160;</td><td class="fielddoc"><p>FIFO threshold of 7/8 full </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac5ed668954e94caaea6e20fe0cd03caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ed668954e94caaea6e20fe0cd03caa">&sect;&nbsp;</a></span>UARTCC26X2_fxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_u_a_r_t_8h.html#ad50e0d914874c8fcbc16b451984a8f5e">UART_FxnTable</a> UARTCC26X2_fxnTable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
