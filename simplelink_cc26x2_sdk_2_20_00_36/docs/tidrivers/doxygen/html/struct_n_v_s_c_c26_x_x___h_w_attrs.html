<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>NVSCC26XX_HWAttrs Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">NVSCC26XX_HWAttrs Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVSCC26XX hardware attributes.  
 <a href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_n_v_s_c_c26_x_x_8h_source.html">NVSCC26XX.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ad5ee322e543d49b4c177f28f4e96f884"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ad5ee322e543d49b4c177f28f4e96f884">regionBase</a></td></tr>
<tr class="separator:ad5ee322e543d49b4c177f28f4e96f884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab479adbd1bbeb60a6849c4611d9f4941"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ab479adbd1bbeb60a6849c4611d9f4941">regionSize</a></td></tr>
<tr class="separator:ab479adbd1bbeb60a6849c4611d9f4941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVSCC26XX hardware attributes. </p>
<p>The NVSCC26XX hardware attributes define hardware specific settings for a NVS driver instance.</p>
<dl class="section note"><dt>Note</dt><dd>Care must be taken to ensure that the linker does not place application content (such as .text or .const) in the flash regions defined by the this hardware attributes structure.</dd></dl>
<p>For CCS and IAR tools, defining and reserving flash memory regions can be done entirely within the Board.c file. For GCC, additional content is required in the application's linker script to achieve the same result.</p>
<p>The example below defines a char array <code>flashBuf</code>. Preprocessor logic is used so that this example will work with either the TI, IAR or GCC tools. For the TI and IAR tools, pragmas are used to place <code>flashBuf</code> at the flash location specified by <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ad5ee322e543d49b4c177f28f4e96f884">NVSCC26XX_HWAttrs.regionBase</a>.</p>
<p>For the GCC tool, the <code>flashBuf</code> array is placed into a named linker output section, <code></code>.nvs. This section is defined in the application's linker script. The section placement command is carefully chosen to only RESERVE space for the <code>flashBuf</code> array, and not to actually initialize it during the application load process, thus preserving the content of flash.</p>
<p>Regardless of tool chain, the <code>flashBuf</code> array in the example below is placed at the <code>NVS_REGIONS_BASE</code> address and has an overall size of <code>REGIONSIZE</code> bytes. Theoretically, the memory reserved by <code>flashBuf</code> can be divided into four separate regions, each having a size of <code>SECTORSIZE</code> bytes. Each region must always be aligned to the flash sector size, <code>SECTORSIZE</code>. This example below shows two regions defined.</p>
<p>An array of two <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html" title="NVSCC26XX hardware attributes. ">NVSCC26XX_HWAttrs</a> structures is defined. Each index of this structure defines a region of on-chip flash memory. Both regions utilize memory reserved by the <code>flashBuf</code> array. The two regions do not overlap or share the same physical memory locations. The two regions do however exist adjacent to each other in physical memory. The first region is defined as starting at the <code>NVS_REGIONS_BASE</code> address and has a size equal to the flash sector size, as defined by <code>SECTORSIZE</code>. The second region is defined as starting at (NVS_REGIONS_BASE + SECTORSIZE), that is, the <code>NVS_REGIONS_BASE</code> address offset by <code>SECTORSIZE</code> bytes. The second region has a size equal to (3 * SECTORSIZE) bytes. These regions together fully occupy <code>REGIONSIZE</code> bytes of physical on-chip flash memory as reserved by the <code>flashBuf</code> array.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NVS_REGIONS_BASE 0x1B000</span></div><div class="line"><span class="preprocessor">#define SECTORSIZE       0x1000</span></div><div class="line"><span class="preprocessor">#define REGIONSIZE       (SECTORSIZE * 4)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Reserve flash sectors for NVS driver use</span></div><div class="line"><span class="comment">// by placing an uninitialized byte array</span></div><div class="line"><span class="comment">// at the desired flash address.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="preprocessor">#if defined(__TI_COMPILER_VERSION__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place uninitialized array at FLASH_REGION_BASE</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="preprocessor">#pragma LOCATION(flashBuf, FLASH_REGION_BASE);</span></div><div class="line"><span class="preprocessor">#pragma NOINIT(flashBuf);</span></div><div class="line"><span class="keywordtype">char</span> flashBuf[REGIONSIZE];</div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined(__IAR_SYSTEMS_ICC__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place uninitialized array at FLASH_REGION_BASE</span></div><div class="line"><span class="comment">//</span></div><div class="line">__no_init <span class="keywordtype">char</span> flashBuf[REGIONSIZE] @ FLASH_REGION_BASE;</div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined(__GNUC__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place the flash buffers in the .nvs section created in the gcc linker file.</span></div><div class="line"><span class="comment">//  The .nvs section enforces alignment on a sector boundary but may</span></div><div class="line"><span class="comment">//  be placed anywhere in flash memory.  If desired the .nvs section can be set</span></div><div class="line"><span class="comment">//  to a fixed address by changing the following in the gcc linker file:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  .nvs (FIXED_FLASH_ADDR) (NOLOAD) : AT (FIXED_FLASH_ADDR) {</span></div><div class="line"><span class="comment">//       *(.nvs)</span></div><div class="line"><span class="comment">//  } &gt; REGION_TEXT</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line">__attribute__ ((section (<span class="stringliteral">&quot;.nvs&quot;</span>)))</div><div class="line">char flashBuf[REGIONSIZE];</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a> nvsCC26XXHWAttrs[2] = {</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 0 is 1 flash sector in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ad5ee322e543d49b4c177f28f4e96f884">regionBase</a> = (<span class="keywordtype">void</span> *)flashBuf,</div><div class="line">        .<a class="code" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ab479adbd1bbeb60a6849c4611d9f4941">regionSize</a> = SECTORSIZE,</div><div class="line">    },</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 1 is 3 flash sectors in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .regionBase = (<span class="keywordtype">void</span> *)(flashBuf + SECTORSIZE),</div><div class="line">        .regionSize = SECTORSIZE * 3,</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Example GCC linker script file content. This example places an output section, <code></code>.nvs, at the memory address <code>0x1B000</code>. The <code>NOLOAD</code> directive is used so that this memory is not initialized during program load to the target.</p>
<div class="fragment"><div class="line">MEMORY</div><div class="line">{</div><div class="line">    FLASH (RX)      : ORIGIN = 0x00000000, LENGTH = 0x0001ffa8</div><div class="line">    FLASH_CCFG (RX) : ORIGIN = 0x0001ffa8, LENGTH = 0x00000058</div><div class="line">    SRAM (RWX)      : ORIGIN = 0x20000000, LENGTH = 0x00005000</div><div class="line">}</div><div class="line"></div><div class="line">.nvs (0x1b000) (NOLOAD) : AT (0x1b000) {</div><div class="line">    *(.nvs)</div><div class="line">} &gt; REGION_TEXT</div></div><!-- fragment --><p>If the write "scoreboard" is enabled, three new fields are added to the <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html" title="NVSCC26XX hardware attributes. ">NVSCC26XX_HWAttrs</a> structure:</p><ul>
<li>scoreboard - a buffer provided by the application where each byte represents how many times a page has been written to. It is important that this buffer be large enough such that there is a byte for each page of memory in the NVS region. For example:<ul>
<li>64k NVS region</li>
<li>256 byte page size</li>
<li>64k / 256 = 256; the scoreboard buffer must be 256 bytes in length</li>
</ul>
</li>
<li>scoreboardSize - number of bytes in the scoreboard.</li>
<li>flashPageSize - number of bytes in a flash page (i.e. 128 or 256) </li>
</ul>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="ad5ee322e543d49b4c177f28f4e96f884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ee322e543d49b4c177f28f4e96f884">&sect;&nbsp;</a></span>regionBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NVSCC26XX_HWAttrs::regionBase</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The regionBase field specifies the base address of the on-chip flash memory to be managed. The regionBase must be aligned to the flash sector size. This memory cannot be shared and must be for exclusive use by one NVS driver instance. </p>

</div>
</div>
<a id="ab479adbd1bbeb60a6849c4611d9f4941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab479adbd1bbeb60a6849c4611d9f4941">&sect;&nbsp;</a></span>regionSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NVSCC26XX_HWAttrs::regionSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The regionSize field specifies the overall size of the on-chip flash memory to be managed. The regionSize must be at least 1 flash sector size AND an integer multiple of the flash sector size. For most CC26XX/CC13XX devices, the flash sector size is 4096 bytes. The NVSCC26XX driver will determine the device's actual sector size by reading internal system configuration registers. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_n_v_s_c_c26_x_x_8h_source.html">NVSCC26XX.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
